#!/usr/bin/env bash

# pr-feedback - Show resolvable PR feedback on the currently checked out PR
# Usage:
#   bash pr-feedback [--json] [--human] [--all]

set -euo pipefail

FORMAT="human"
SHOW_ALL=false
DEBUG=false
LIMIT=0

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --json) FORMAT="json"; shift;;
    --human) FORMAT="human"; shift;;
    --all) SHOW_ALL=true; shift;;
    --limit|-l) LIMIT="$2"; shift 2;;
    --debug) DEBUG=true; shift;;
    -h|--help)
      cat <<EOF
Usage: $0 [options]

Options:
  --json             JSON output format
  --human            Human-readable format (default)
  --all              Show all comments, including resolved ones
  --limit|-l N       Limit number of results
  --debug            Show debug information
  -h, --help         Show this help

Examples:
  $0
  $0 --json
  $0 --all
  $0 --limit 10
EOF
      exit 0
      ;;
    *) echo "Unknown option: $1" >&2; exit 1;;
  esac
done

# Get current PR number
PR_INFO=$(gh pr view --json number,title,url,headRefName 2>&1) || {
  echo "Error: No pull request found for current branch." >&2
  echo "Make sure you're on a branch with an associated PR." >&2
  exit 1
}

PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number')
PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
PR_URL=$(echo "$PR_INFO" | jq -r '.url')
BRANCH=$(echo "$PR_INFO" | jq -r '.headRefName')

if [[ "$PR_NUMBER" == "null" ]] || [[ -z "$PR_NUMBER" ]]; then
  echo "Error: Could not determine PR number." >&2
  exit 1
fi

# Debug output
if [[ "$DEBUG" == true ]]; then
  echo "Debug: PR Number: $PR_NUMBER" >&2
  echo "Debug: PR Title: $PR_TITLE" >&2
  echo "Debug: Branch: $BRANCH" >&2
  echo "Debug: Limit: ${LIMIT:-0}" >&2
fi

# Get repository owner and name
REPO_INFO=$(gh repo view --json owner,name 2>&1) || {
  echo "Error: Could not determine repository information." >&2
  exit 1
}

OWNER=$(echo "$REPO_INFO" | jq -r '.owner.login')
REPO=$(echo "$REPO_INFO" | jq -r '.name')

if [[ "$DEBUG" == true ]]; then
  echo "Debug: Repository: $OWNER/$REPO" >&2
fi

# Get review comment threads using GraphQL (includes resolution status)
# Note: PR_NUMBER must be passed as an integer, not a string
THREADS_JSON=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $prNumber: Int!) {
    repository(owner: $owner, name: $repo) {
      pullRequest(number: $prNumber) {
        reviewThreads(first: 100) {
          nodes {
            id
            isResolved
            isOutdated
            comments(first: 100) {
              nodes {
                id
                body
                author {
                  login
                }
                createdAt
                path
                line
                startLine
                diffHunk
                url
              }
            }
          }
        }
      }
    }
  }
' -f owner="$OWNER" -f repo="$REPO" -F prNumber="$PR_NUMBER" 2>&1) || {
  echo "Error: Failed to fetch review threads." >&2
  if [[ "$DEBUG" == true ]]; then
    echo "Debug: Owner: $OWNER, Repo: $REPO, PR Number: $PR_NUMBER" >&2
    echo "Debug: GraphQL response: $THREADS_JSON" >&2
  fi
  exit 1
}

# Extract comments from threads, filtering by resolution status
if [[ "$SHOW_ALL" == true ]]; then
  # Show all non-outdated comments
  FILTERED_COMMENTS=$(echo "$THREADS_JSON" | jq -r '
    .data.repository.pullRequest.reviewThreads.nodes[] |
    select(.isOutdated == false) |
    . as $thread |
    .comments.nodes[] |
    select(.body != null and .body != "") |
    {
      id: .id,
      threadId: $thread.id,
      body: .body,
      author: .author.login,
      createdAt: .createdAt,
      path: .path,
      line: (.line // .startLine),
      diffHunk: .diffHunk,
      url: .url,
      isResolved: $thread.isResolved
    }
  ' | jq -s '.')
else
  # Only show unresolved, non-outdated comments
  FILTERED_COMMENTS=$(echo "$THREADS_JSON" | jq -r '
    .data.repository.pullRequest.reviewThreads.nodes[] |
    select(.isResolved == false and .isOutdated == false) |
    . as $thread |
    .comments.nodes[] |
    select(.body != null and .body != "") |
    {
      id: .id,
      threadId: $thread.id,
      body: .body,
      author: .author.login,
      createdAt: .createdAt,
      path: .path,
      line: (.line // .startLine),
      diffHunk: .diffHunk,
      url: .url,
      isResolved: false
    }
  ' | jq -s '.')
fi

# If GraphQL didn't return valid data, try REST API fallback
if [[ -z "$FILTERED_COMMENTS" ]] || [[ "$FILTERED_COMMENTS" == "[]" ]] || [[ "$FILTERED_COMMENTS" == "null" ]]; then
  if [[ "$DEBUG" == true ]]; then
    echo "Debug: GraphQL returned no results, trying REST API fallback" >&2
  fi
  
  # Fetch review comments using REST API
  COMMENTS_JSON=$(gh api "repos/$OWNER/$REPO/pulls/$PR_NUMBER/comments" 2>&1) || {
    echo "Error: Failed to fetch review comments." >&2
    exit 1
  }
  
  # Convert REST API format to our format
  FILTERED_COMMENTS=$(echo "$COMMENTS_JSON" | jq '
    map({
      id: (.id | tostring),
      threadId: (.id | tostring),  # For REST API, use comment ID as thread ID fallback
      body: .body,
      author: .user.login,
      createdAt: .created_at,
      path: .path,
      line: (.line // .start_line),
      diffHunk: .diff_hunk,
      url: .html_url,
      isResolved: false
    })
  ')
fi

# Apply limit if specified
if [[ "$LIMIT" -gt 0 ]]; then
  FILTERED_COMMENTS=$(echo "$FILTERED_COMMENTS" | jq --argjson limit "$LIMIT" 'if type == "array" then .[:$limit] else . end')
fi

# Count comments - handle empty arrays and null
COMMENT_COUNT=$(echo "$FILTERED_COMMENTS" | jq 'if . == null or . == [] then 0 elif type == "array" then length else 0 end')

# Function to calculate relative time
relative_time() {
  local timestamp="$1"
  local now=$(date +%s)
  local then=$(date -d "$timestamp" +%s 2>/dev/null || echo "$now")
  local diff=$((now - then))
  
  if [[ $diff -lt 3600 ]]; then
    echo "$((diff / 60))m ago"
  elif [[ $diff -lt 86400 ]]; then
    echo "$((diff / 3600))h ago"
  elif [[ $diff -lt 604800 ]]; then
    echo "$((diff / 86400))d ago"
  else
    echo "$((diff / 604800))w ago"
  fi
}

# Output based on format
if [[ "$FORMAT" == "json" ]]; then
  echo "$FILTERED_COMMENTS" | jq '.'
else
  # Human-readable format
  echo "PR #$PR_NUMBER: $PR_TITLE"
  echo "Branch: $BRANCH"
  echo "URL: $PR_URL"
  echo ""
  
  if [[ "$COMMENT_COUNT" -eq 0 ]]; then
    if [[ "$SHOW_ALL" == true ]]; then
      echo "No review comments found."
    else
      echo "No unresolved review comments found."
      echo ""
      echo "Use --all to show all comments including resolved ones."
    fi
    exit 0
  fi
  
  if [[ "$LIMIT" -gt 0 ]]; then
    echo "Found $COMMENT_COUNT resolvable review comment(s) (showing up to $LIMIT):"
  else
    echo "Found $COMMENT_COUNT resolvable review comment(s):"
  fi
  echo ""
  
  # Get terminal width (default to 80 if not available)
  TERM_WIDTH=${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}
  
  # Print comments - process each comment as JSON to handle special characters
  echo "$FILTERED_COMMENTS" | jq -c '.[]' | while IFS= read -r comment_json; do
    id=$(echo "$comment_json" | jq -r '.id')
    thread_id=$(echo "$comment_json" | jq -r '.threadId // .id')
    author=$(echo "$comment_json" | jq -r '.author')
    created=$(echo "$comment_json" | jq -r '.createdAt')
    path=$(echo "$comment_json" | jq -r '.path // "general"')
    line=$(echo "$comment_json" | jq -r '.line // "N/A"')
    body=$(echo "$comment_json" | jq -r '.body')
    url=$(echo "$comment_json" | jq -r '.url')
    
    relative=$(relative_time "$created")
    
    # Color formatting
    color_reset=$'\033[0m'
    color_author=$'\033[36m'  # Cyan
    color_path=$'\033[33m'   # Yellow
    color_line=$'\033[90m'   # Gray
    color_id=$'\033[35m'    # Magenta
    
    echo -e "${color_id}[Thread: ${thread_id}]${color_reset} ${color_author}@${author}${color_reset} ${color_path}${path}${color_reset}:${color_line}${line}${color_reset} (${relative})"
    echo ""
    
    # Format body with word wrapping
    echo "$body" | fold -w $((TERM_WIDTH - 2)) -s | sed 's/^/  /'
    echo ""
    echo -e "  ${color_line}â†’ ${url}${color_reset}"
    echo ""
    echo "$(printf '%*s' $TERM_WIDTH '' | tr ' ' '-')"
    echo ""
  done
fi
